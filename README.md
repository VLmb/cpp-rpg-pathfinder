# Описание лабораторной работы

## Общая идея и цель

Разрабатывается приложение на C++ с использованием Qt (Qt Creator), предназначенное для работы с графами на клеточной карте. Карта представляет собой сетку размера n×n с различными типами поверхностей (биомами). Пользователь может вручную задать граф на этой карте, выбрав клетки-вершины и установив между ними рёбра.

После задания графа пользователь выбирает:
- тип героя
- стартовую вершину
- конечную вершину

Приложение находит оптимальный по времени путь между стартом и финишем с учётом:
- проходимости карты
- характеристик героя
- структуры пользовательского графа

Вот обновленные разделы описания с учетом всех последних изменений в коде и логике генерации.

## Карта (grid) и типы поверхностей

Карта представляет собой матрица $n \times m$, где каждая клетка хранит информацию о биоме и физических характеристиках местности.

**Многослойная генерация**
Для создания реалистичного и разнообразного ландшафта используется **три независимых слоя** процедурного шума. Это позволяет избежать примитивной зависимости «чем выше, тем зеленее» и создавать сложные биомы (например, болота в низинах или густые леса на возвышенностях).

Каждая клетка характеризуется тремя нормализованными параметрами (диапазон $[0; 1]$):
1.  **Altitude — Высота:** Определяет рельеф местности. Делит карту на низины, холмистую местность и высокие горные пики.
2.  **Temperature — Температура:** Определяет климатический сезон. Разделяет биомы на «теплые» (летние) и «зимние».
3.  **Moisture — Влажность:** Влияет на растительность. Низкая влажность формирует равнины и пустоши, высокая — густые леса и джунгли.

**Биомы**
На основе комбинации высоты, температуры и влажности клетке присваивается конкретный тип (`BiomeType`). Логика определения биома иерархична (сначала высота, затем температура, затем влажность):

*   **Низины (Low Altitude):**
    *   `PLAIN` — Равнина (тепло, сухо).
    *   `FOREST` — Лес (тепло, влажно).
    *   `WINTER_PLAIN` — Заснеженная равнина (холодно, сухо).
    *   `WINTER_FOREST` — Заснеженный лес (холодно, влажно).

*   **Холмогорья (Mid Altitude):**
    *   `HILLS` — Холмы (тепло, сухо).
    *   `HILLY_JUNGLE` — Холмистые джунгли (тепло, влажно).
    *   `WINTER_HILLS` — Заснеженные холмы (холодно, сухо).
    *   `HILLY_WINTER_FOREST` — Холмистый зимний лес (холодно, влажно).

*   **Высокогорье (High Altitude):**
    *   `ROCKY_PEAKS` — Скалистые пики (преобладают на большой высоте).
    *   `SNOWY_ROCKS` — Заснеженные скалы (формируются только при очень высокой влажности и холоде).

Также в приложении реализован режим **упрощенной генерации** (`generateSimplifiedMap`), где карта разбивается на три базовые зоны для тестов производительности или отладки графов.

## Алгоритм шума Перлина (Perlin Noise)

Генерация карт выполняется с помощью вручную реализованного алгоритма **Perlin Noise** (Gradient Noise). Это позволяет получать псевдослучайные значения, которые плавно изменяются в пространстве (пространственная когерентность).

**Принцип работы:**
1.  **Сетка градиентов:** Пространство разбивается на клеточную решетку. В каждом узле решетки генерируется псевдослучайный единичный градиентный вектор (выбор из 8 направлений для устранения артефактов "квадратности").
2.  **Скалярное произведение:** Для любой точки внутри клетки вычисляются векторы расстояний до 4-х ближайших узлов. Затем находится скалярное произведение (Dot Product) между вектором расстояния и градиентным вектором узла.
3.  **Сглаживание и Интерполяция:** Полученные значения интерполируются. Чтобы переходы были идеально плавными (без резких швов), используется кривая сглаживания 5-й степени (Quintic Curve: $6t^5 - 15t^4 + 10t^3$).

**Фрактальное движение (Octaves):**
Для придания ландшафту естественной детализации шум накладывается в несколько слоев (октав). Каждая следующая октава имеет удвоенную частоту и уменьшенную амплитуду (Persistence). Это создает эффект «больших гор с мелкими камнями».

## Герои и физика передвижения

В системе реализована процедурная модель проходимости. Скорость перемещения героя по клетке не задается константами (например, «по лесу скорость 5»), а рассчитывается динамически по формуле, учитывающей соответствие климата предпочтениям героя.

**Формула расчета:**
У каждого героя есть три коэффициента предпочтения (Preferences): к **Температуре**, **Высоте** и **Влажности**.
Скорость на конкретной клетке вычисляется как взвешенное произведение параметров местности на предпочтения героя:
$$Speed = \frac{(T_{cell} \cdot P_{temp} + A_{cell} \cdot P_{alt} + M_{cell} \cdot P_{moist}) \cdot BaseSpeed}{3}$$
*Чем лучше местность соответствует природе героя, тем быстрее он по ней движется. Время прохождения клетки обратно пропорционально скорости.*

**Классы героев:**

*   **Лесной Эльф (Wood Elf)**
    *   *Специализация:* **Влажность (Moisture).**
    *   *Характеристика:* Имеет колоссальный бонус к скорости во влажных биомах (леса, джунгли, болота). Практически не способен передвигаться в сухих пустынях или на сухих скалах.

*   **Орк (Orc)**
    *   *Специализация:* **Температура (Temperature).**
    *   *Характеристика:* Теплолюбив. Развивает максимальную скорость в жарких регионах (равнины, пустыни). Крайне медлителен в холодных зонах (зимние биомы).

*   **Горный Гном (Gnome)**
    *   *Специализация:* **Высота (Altitude).**
    *   *Характеристика:* Житель гор. Чем выше местность (холмы, скалистые пики), тем быстрее он движется. Испытывает трудности при передвижении по низинам.

*   **Человек (Human)**
    *   *Специализация:* **Универсал.**
    *   *Характеристика:* Обладает сбалансированными предпочтениями ко всем типам местности (коэффициенты равны `1.0`) и повышенной базовой скоростью (`BaseSpeed = 10.0`). Это делает человека стабильным выбором для карт со смешанным ландшафтом, где нет доминирующего экстремального биома.

## Граф

Пользователь взаимодействует с картой следующим образом:
- выбирает клетки и помечает их как вершины графа;
- соединяет выбранные вершины рёбрами;
- задаёт стартовую и конечную вершины.

Граф задаёт разрешённые переходы между вершинами, но не заменяет реальное перемещение по карте.

## Поиск оптимального пути

**Расчёт веса рёбер (A\*)**
Для каждой пары соединённых вершин пользовательского графа вычисляется вес ребра с помощью алгоритма A*, работающего на уровне клеточной карты.

Алгоритм A* учитывает:
- типы поверхностей клеток;
- характеристики выбранного героя;
- допустимые направления перемещения (4-соседняя сетка).

Результатом работы A* является:
- минимальное время перемещения между двумя вершинами;
- конкретный путь по клеткам карты.
  
Для ускорения повторных вычислений используется кэширование путей: найденные маршруты сохраняются и повторно используются при запросе того же пути для того же героя.

**Поиск пути по графу (Дейкстра)**
После вычисления весов рёбер запускается алгоритм Дейкстры по пользовательскому графу. Итогом является оптимальный маршрут между стартовой и конечной вершинами.

## Используемые структуры данных

**Очередь с приоритетом (PriorityQueue)**

Для реализации алгоритма A* используется собственная реализация очереди с приоритетом (PriorityQueue).

Очередь основана на бинарной куче и поддерживает операции:
- добавление элемента с приоритетом;
- извлечение элемента с минимальным приоритетом.

Очередь параметризуется функцией-компаратором, что позволяет использовать её с произвольными типами данных и критериями приоритета.

**Хеш-таблица (HashMap)**

Для кэширования найденных путей используется собственная реализация хеш-таблицы (HashMap).
Ключом в хеш-таблице является составная структура, включающая:
- стартовую точку;
- конечную точку;
- указатель на героя.

Значением является путь, представленный последовательностью клеток карты.
Хеш-таблица использует метод раздельных цепочек для обработки коллизий и автоматически увеличивает размер при превышении заданного коэффициента заполнения.
