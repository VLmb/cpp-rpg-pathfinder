# Описание лабораторной работы

## Общая идея и цель

Разрабатывается приложение на C++ с использованием Qt (Qt Creator), предназначенное для работы с графами на клеточной карте. Карта представляет собой сетку размера n×n с различными типами поверхностей (биомами). Пользователь может вручную задать граф на этой карте, выбрав клетки-вершины и установив между ними рёбра.

После задания графа пользователь выбирает:
- тип героя
- стартовую вершину
- конечную вершину

Приложение находит оптимальный по времени путь между стартом и финишем с учётом:
- проходимости карты
- характеристик героя
- структуры пользовательского графа

Вот обновленные разделы описания с учетом всех последних изменений в коде и логике генерации.

## Карта (grid) и типы поверхностей

Карта представляет собой матрица $n \times m$, где каждая клетка (`TerrainType`) хранит информацию о биоме и физических характеристиках местности.

**Многослойная генерация**
Для создания реалистичного и разнообразного ландшафта используется **три независимых слоя** процедурного шума. Это позволяет избежать примитивной зависимости «чем выше, тем зеленее» и создавать сложные биомы (например, болота в низинах или густые леса на возвышенностях).

Каждая клетка характеризуется тремя нормализованными параметрами (диапазон $[0; 1]$):
1.  **Rockiness — Скалистость/Высота:** Определяет рельеф. Низкие значения формируют водоемы, средние — равнины, высокие — скалы и пики.
2.  **Vegetation — Растительность:** Определяет плотность флоры. Низкие значения — пустоши, высокие — непроходимые чащи.
3.  **Moisture — Влажность:** Определяет вязкость и климат. Влияет на формирование болот, пустынь или снежных шапок.

**Биомы**
На основе комбинации этих трех параметров клетке присваивается конкретный визуальный тип (`BiomeType`):
*   `WATER` — Водоемы (низкий $R$).
*   `SAND` — Песчаные пустоши (низкая $M$, средний $R$).
*   `PLAIN` — Равнины и луга (сбалансированные параметры).
*   `SWAMP` — Топи и болота (низкий $R$, очень высокая $M$).
*   `FOREST` / `DENSE_FOREST` — Леса различной плотности (зависят от $V$).
*   `MOUNTAIN` — Скалистая местность (высокий $R$, низкая $M$).
*   `SNOW` — Снежные вершины (высокий $R$, высокая $M$).

Для визуализации используется специально подобранная цветовая палитра.

## Алгоритм шума Перлина (Perlin Noise)

Генерация карт выполняется с помощью вручную реализованного алгоритма **Perlin Noise** (Gradient Noise). Это позволяет получать псевдослучайные значения, которые плавно изменяются в пространстве (пространственная когерентность).

**Принцип работы:**
1.  **Сетка градиентов:** Пространство разбивается на клеточную решетку. В каждом узле решетки генерируется псевдослучайный единичный градиентный вектор (выбор из 8 направлений для устранения артефактов "квадратности").
2.  **Скалярное произведение:** Для любой точки внутри клетки вычисляются векторы расстояний до 4-х ближайших узлов. Затем находится скалярное произведение (Dot Product) между вектором расстояния и градиентным вектором узла.
3.  **Сглаживание и Интерполяция:** Полученные значения интерполируются. Чтобы переходы были идеально плавными (без резких швов), используется кривая сглаживания 5-й степени (Quintic Curve: $6t^5 - 15t^4 + 10t^3$).

**Фрактальное движение (Octaves):**
Для придания ландшафту естественной детализации шум накладывается в несколько слоев (октав). Каждая следующая октава имеет удвоенную частоту и уменьшенную амплитуду (Persistence). Это создает эффект «больших гор с мелкими камнями».

## Герои и физика передвижения

В системе реализована ролевая модель проходимости. Вместо жестко заданных штрафов для типов поверхности, скорость передвижения рассчитывается динамически на основе трех осей ландшафта и навыков героя.

Каждый класс героя имеет набор коэффициентов, отражающих его способность преодолевать конкретные препятствия.

**Реализованные классы:**
*   **Дворф (Dwarf):** Мастер гор, плохо передвигается в воде и густых лесах из-за роста и тяжелой экипировки.
*   **Лесной Эльф (Wood Elf):** Лесной эльф. Идельно передвигается в густой растительности, но плох в передвижении по скалистым местностям и равнинам
*   **Человек (Human):** Универсал со сбалансированными характеристиками.

## Граф

Пользователь взаимодействует с картой следующим образом:
- выбирает клетки и помечает их как вершины графа;
- соединяет выбранные вершины рёбрами;
- задаёт стартовую и конечную вершины.

Граф задаёт разрешённые переходы между вершинами, но не заменяет реальное перемещение по карте.

## Поиск оптимального пути

**Расчёт веса рёбер (A\*)**
Для каждой пары соединённых вершин пользовательского графа вычисляется вес ребра с помощью алгоритма A*, работающего на уровне клеточной карты.

Алгоритм A* учитывает:
- типы поверхностей клеток;
- характеристики выбранного героя;
- допустимые направления перемещения (4-соседняя сетка).

Результатом работы A* является:
- минимальное время перемещения между двумя вершинами;
- конкретный путь по клеткам карты.
  
Для ускорения повторных вычислений используется кэширование путей: найденные маршруты сохраняются и повторно используются при запросе того же пути для того же героя.

**Поиск пути по графу (Дейкстра)**
После вычисления весов рёбер запускается алгоритм Дейкстры по пользовательскому графу. Итогом является оптимальный маршрут между стартовой и конечной вершинами.

## Используемые структуры данных

**Очередь с приоритетом (PriorityQueue)**

Для реализации алгоритма A* используется собственная реализация очереди с приоритетом (PriorityQueue).

Очередь основана на бинарной куче и поддерживает операции:
- добавление элемента с приоритетом;
- извлечение элемента с минимальным приоритетом.

Очередь параметризуется функцией-компаратором, что позволяет использовать её с произвольными типами данных и критериями приоритета.

**Хеш-таблица (HashMap)**

Для кэширования найденных путей используется собственная реализация хеш-таблицы (HashMap).
Ключом в хеш-таблице является составная структура, включающая:
- стартовую точку;
- конечную точку;
- указатель на героя.

Значением является путь, представленный последовательностью клеток карты.
Хеш-таблица использует метод раздельных цепочек для обработки коллизий и автоматически увеличивает размер при превышении заданного коэффициента заполнения.
